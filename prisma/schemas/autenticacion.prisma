/**
 * AUTENTICACION Module - Database Schema
 *
 * Modelos para gestionar autenticación, sesiones y tokens de recuperación.
 *
 * Enums:
 * - TipoUsuarioAuth: Tipo de usuario (CLIENTE, EMPLEADO)
 * - EstadoCuenta: Estado de la cuenta (ACTIVA, INACTIVA, BLOQUEADA, PENDIENTE_VERIFICACION)
 * - EstadoSesion: Estado de sesión (ACTIVA, REVOCADA, EXPIRADA)
 * - TipoTokenRecuperacion: Tipo de token (RECUPERACION_PASSWORD, VERIFICACION_EMAIL)
 * - EstadoToken: Estado del token (PENDIENTE, USADO, EXPIRADO, INVALIDADO)
 * - TipoEventoAuth: Tipos de eventos de autenticación
 * - ResultadoAuth: Resultado del evento (EXITOSO, FALLIDO)
 *
 * Invariantes:
 * - cuenta_usuario.email: UNIQUE (identificador único)
 * - cuenta_usuario.cliente_id: UNIQUE (un cliente una cuenta)
 * - cuenta_usuario.empleado_id: UNIQUE (un empleado una cuenta)
 * - sesion_usuario.refresh_token_hash: UNIQUE (un token una sesión)
 * - token_recuperacion.token_hash: UNIQUE (un token de recuperación)
 *
 * Notas de seguridad:
 * - password_hash: bcrypt cost factor 12
 * - refresh_token_hash: SHA-256 del token opaco
 * - token_hash: SHA-256 del token de recuperación
 * - NUNCA almacenar tokens en texto plano
 */

enum TipoUsuarioAuth {
  CLIENTE
  EMPLEADO

  @@map("tipo_usuario_auth")
}

enum EstadoCuenta {
  ACTIVA
  INACTIVA
  BLOQUEADA
  PENDIENTE_VERIFICACION

  @@map("estado_cuenta")
}

enum EstadoSesion {
  ACTIVA
  REVOCADA
  EXPIRADA

  @@map("estado_sesion")
}

enum TipoTokenRecuperacion {
  RECUPERACION_PASSWORD
  VERIFICACION_EMAIL

  @@map("tipo_token_recuperacion")
}

enum EstadoToken {
  PENDIENTE
  USADO
  EXPIRADO
  INVALIDADO

  @@map("estado_token")
}

enum TipoEventoAuth {
  LOGIN
  LOGOUT
  REFRESH_TOKEN
  CAMBIO_PASSWORD
  RECUPERACION_PASSWORD_SOLICITUD
  RECUPERACION_PASSWORD_USO
  VERIFICACION_EMAIL
  BLOQUEO_CUENTA
  DESBLOQUEO_CUENTA
  REVOCACION_SESION
  REVOCACION_MASIVA
  CREACION_CUENTA_EMPLEADO

  @@map("tipo_evento_auth")
}

enum ResultadoAuth {
  EXITOSO
  FALLIDO

  @@map("resultado_auth")
}

/**
 * CuentaUsuario: Credenciales de acceso para clientes y empleados.
 *
 * Almacena credenciales unificadas para autenticación.
 * Ciclo de vida: PENDIENTE_VERIFICACION → ACTIVA → INACTIVA
 *
 * Campos:
 * - id: UUID v7 (generado por aplicación)
 * - email: Email único (usado como username)
 * - password_hash: Hash bcrypt (cost factor 12)
 * - tipo_usuario: CLIENTE o EMPLEADO
 * - cliente_id: FK → Cliente (solo si tipo = CLIENTE)
 * - empleado_id: FK → Empleado (solo si tipo = EMPLEADO)
 * - estado: Estado actual de la cuenta
 * - email_verificado: Si el email fue verificado
 * - intentos_fallidos: Contador de intentos fallidos consecutivos
 * - numero_bloqueos: Contador histórico de veces que fue bloqueada
 * - bloqueado_hasta: Si está bloqueada temporalmente
 * - ultimo_login: Fecha del último login exitoso
 * - ultimo_cambio_password: Fecha del último cambio de contraseña
 * - fecha_creacion: Cuándo fue creada
 * - fecha_modificacion: Última modificación
 *
 * Relaciones:
 * - 0..1 : 1 con Cliente (un cliente puede tener una cuenta)
 * - 0..1 : 1 con Empleado (un empleado puede tener una cuenta)
 * - 1 : 0..* con SesionUsuario (una cuenta puede tener múltiples sesiones)
 * - 1 : 0..* con TokenRecuperacion (una cuenta puede tener múltiples tokens)
 * - 1 : 0..* con LogAutenticacion (una cuenta puede tener múltiples logs)
 *
 * Índices:
 * - UNIQUE en email (lookup primario)
 * - UNIQUE en cliente_id (un cliente una cuenta)
 * - UNIQUE en empleado_id (un empleado una cuenta)
 * - INDEX en estado (filtrado por estado)
 */
model CuentaUsuario {
  id                    String            @id @default(uuid()) @db.Uuid
  email                 String            @unique @db.VarChar(100)
  passwordHash          String            @map("password_hash") @db.VarChar(255)
  tipoUsuario           TipoUsuarioAuth   @map("tipo_usuario")
  clienteId             String?           @unique @map("cliente_id") @db.Uuid
  empleadoId            String?           @unique @map("empleado_id") @db.Uuid
  estado                EstadoCuenta      @default(PENDIENTE_VERIFICACION) @map("estado")
  emailVerificado       Boolean           @default(false) @map("email_verificado")
  intentosFallidos      Int               @default(0) @map("intentos_fallidos")
  numeroBloqueos        Int               @default(0) @map("numero_bloqueos")
  bloqueadoHasta        DateTime?         @map("bloqueado_hasta")
  ultimoLogin           DateTime?         @map("ultimo_login")
  ultimoCambioPassword  DateTime?         @map("ultimo_cambio_password")
  fechaCreacion         DateTime          @default(now()) @map("fecha_creacion")
  fechaModificacion     DateTime          @updatedAt @map("fecha_modificacion")

  sesiones              SesionUsuario[]   @relation("CuentaSesiones")
  sesionesRevocadas     SesionUsuario[]   @relation("CuentaRevocadora")
  tokensRecuperacion    TokenRecuperacion[]
  logsAutenticacion     LogAutenticacion[]

  // TODO: Agregar relaciones a Cliente y Empleado cuando módulos estén disponibles
  // cliente              Cliente?          @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  // empleado             Empleado?         @relation(fields: [empleadoId], references: [id], onDelete: Cascade)

  @@index([email], name: "idx_cuenta_usuario_email")
  @@index([clienteId], name: "idx_cuenta_usuario_cliente")
  @@index([empleadoId], name: "idx_cuenta_usuario_empleado")
  @@index([estado], name: "idx_cuenta_usuario_estado")
  @@map("cuenta_usuario")
}

/**
 * SesionUsuario: Refresh tokens y sesiones activas.
 *
 * Almacena refresh tokens hasheados y estado de sesiones.
 * Ciclo de vida: ACTIVA → REVOCADA o EXPIRADA
 *
 * Campos:
 * - id: UUID v7 (generado por aplicación)
 * - cuenta_usuario_id: FK → CuentaUsuario
 * - refresh_token_hash: Hash SHA-256 del refresh token opaco
 * - dispositivo: User-Agent o identificador del dispositivo
 * - estado: Estado actual de la sesión
 * - fecha_creacion: Cuándo fue creada
 * - fecha_expiracion: Cuándo expira
 * - fecha_ultimo_uso: Último uso del refresh token
 * - fecha_revocacion: Si fue revocada manualmente
 * - revocada_por: FK → CuentaUsuario (admin que revocó)
 * - motivo_revocacion: Razón de revocación
 *
 * Relaciones:
 * - N : 1 con CuentaUsuario (muchas sesiones de una cuenta)
 * - N : 0..1 con CuentaUsuario (muchas sesiones revocadas por un admin)
 *
 * Índices:
 * - INDEX en cuenta_usuario_id (lookup por cuenta)
 * - UNIQUE en refresh_token_hash (validación de token)
 * - INDEX en estado (filtrado por estado)
 * - COMPOSITE INDEX en (estado, fecha_expiracion) (limpieza de expiradas)
 */
model SesionUsuario {
  id                 String        @id @default(uuid()) @db.Uuid
  cuentaUsuarioId    String        @map("cuenta_usuario_id") @db.Uuid
  refreshTokenHash   String        @unique @map("refresh_token_hash") @db.VarChar(255)
  dispositivo        String?       @db.VarChar(200)
  estado             EstadoSesion  @default(ACTIVA) @map("estado")
  fechaCreacion      DateTime      @default(now()) @map("fecha_creacion")
  fechaExpiracion    DateTime      @map("fecha_expiracion")
  fechaUltimoUso     DateTime?     @map("fecha_ultimo_uso")
  fechaRevocacion    DateTime?     @map("fecha_revocacion")
  revocadaPor        String?       @map("revocada_por") @db.Uuid
  motivoRevocacion   String?       @map("motivo_revocacion") @db.VarChar(200)

  cuentaUsuario      CuentaUsuario @relation("CuentaSesiones", fields: [cuentaUsuarioId], references: [id], onDelete: Cascade)
  revocadorCuenta    CuentaUsuario? @relation("CuentaRevocadora", fields: [revocadaPor], references: [id], onDelete: SetNull)

  @@index([cuentaUsuarioId], name: "idx_sesion_usuario_cuenta")
  @@index([refreshTokenHash], name: "idx_sesion_usuario_refresh_hash")
  @@index([estado], name: "idx_sesion_usuario_estado")
  @@index([estado, fechaExpiracion], name: "idx_sesion_usuario_expiracion")
  @@map("sesion_usuario")
}

/**
 * TokenRecuperacion: Tokens de recuperación de password y verificación de email.
 *
 * Almacena tokens hasheados para reset de password y verificación de email.
 * Ciclo de vida: PENDIENTE → USADO, EXPIRADO o INVALIDADO
 *
 * Campos:
 * - id: UUID v7 (generado por aplicación)
 * - cuenta_usuario_id: FK → CuentaUsuario
 * - tipo_token: RECUPERACION_PASSWORD o VERIFICACION_EMAIL
 * - token_hash: Hash SHA-256 del token
 * - estado: Estado actual del token
 * - fecha_creacion: Cuándo fue creado
 * - fecha_expiracion: Cuándo expira
 * - fecha_uso: Cuándo fue usado
 * - ip_uso: IP desde donde se usó el token
 *
 * Relaciones:
 * - N : 1 con CuentaUsuario (muchos tokens de una cuenta)
 *
 * Índices:
 * - INDEX en cuenta_usuario_id (lookup por cuenta)
 * - UNIQUE en token_hash (validación de token)
 * - COMPOSITE INDEX en (tipo_token, estado) (filtrado)
 */
model TokenRecuperacion {
  id                 String                 @id @default(uuid()) @db.Uuid
  cuentaUsuarioId    String                 @map("cuenta_usuario_id") @db.Uuid
  tipoToken          TipoTokenRecuperacion  @map("tipo_token")
  tokenHash          String                 @unique @map("token_hash") @db.VarChar(255)
  estado             EstadoToken            @default(PENDIENTE) @map("estado")
  fechaCreacion      DateTime               @default(now()) @map("fecha_creacion")
  fechaExpiracion    DateTime               @map("fecha_expiracion")
  fechaUso           DateTime?              @map("fecha_uso")

  cuentaUsuario      CuentaUsuario          @relation(fields: [cuentaUsuarioId], references: [id], onDelete: Cascade)

  @@index([cuentaUsuarioId], name: "idx_token_recuperacion_cuenta")
  @@index([tokenHash], name: "idx_token_recuperacion_hash")
  @@index([tipoToken, estado], name: "idx_token_recuperacion_tipo_estado")
  @@map("token_recuperacion")
}

/**
 * LogAutenticacion: Auditoría inmutable de eventos de autenticación.
 *
 * Almacena logs de todos los eventos de autenticación (exitosos y fallidos).
 * Tabla INSERT-only (no permite UPDATE ni DELETE).
 *
 * Campos:
 * - id: UUID v7 (generado por aplicación)
 * - email_intento: Email usado en el intento
 * - cuenta_usuario_id: FK → CuentaUsuario (si existe)
 * - tipo_evento: Tipo de evento de autenticación
 * - resultado: EXITOSO o FALLIDO
 * - motivo_fallo: Razón del fallo
 * - ip_origen: IP desde donde se originó el evento
 * - user_agent: User-Agent del navegador
 * - metadata: Datos adicionales en formato JSON
 * - fecha_evento: Cuándo ocurrió el evento
 *
 * Relaciones:
 * - N : 0..1 con CuentaUsuario (muchos logs de una cuenta, pero puede no existir cuenta)
 *
 * Índices:
 * - COMPOSITE INDEX en (email_intento, fecha_evento) (búsqueda por email)
 * - COMPOSITE INDEX en (cuenta_usuario_id, fecha_evento) (búsqueda por cuenta)
 * - COMPOSITE INDEX en (tipo_evento, fecha_evento) (búsqueda por tipo)
 * - INDEX en ip_origen (análisis de seguridad)
 */
model LogAutenticacion {
  id                 String          @id @default(uuid()) @db.Uuid
  emailIntento       String          @map("email_intento") @db.VarChar(100)
  cuentaUsuarioId    String?         @map("cuenta_usuario_id") @db.Uuid
  tipoEvento         TipoEventoAuth  @map("tipo_evento")
  resultado          ResultadoAuth   @map("resultado")
  motivoFallo        String?         @map("motivo_fallo") @db.VarChar(100)
  userAgent          String?         @map("user_agent") @db.VarChar(500)
  metadata           Json?           @map("metadata")
  fechaEvento        DateTime        @default(now()) @map("fecha_evento")

  cuentaUsuario      CuentaUsuario?  @relation(fields: [cuentaUsuarioId], references: [id], onDelete: SetNull)

  @@index([emailIntento, fechaEvento], name: "idx_log_auth_email_fecha")
  @@index([cuentaUsuarioId, fechaEvento], name: "idx_log_auth_cuenta_fecha")
  @@index([tipoEvento, fechaEvento], name: "idx_log_auth_tipo_fecha")
  @@map("log_autenticacion")
}
